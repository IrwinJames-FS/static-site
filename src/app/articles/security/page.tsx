import { Article, Section, Title, P, Code, B, Link } from "@/components";
import { Metadata } from "next";

const Page = () => (<Article>
	<Section>
		<Title h={3} title="Securing your Api and things to avoid"/>
		<P>This article I will try to keep the practices library agnostic because libraries will change over time. With that being said I think it is important to mention libraries like bcrypt and passportjs have been around for quite a while but are not the only libraries of their type.</P>
	</Section>
	<Section>
		<Title step={1} h={5} title="Sessions"/>
		<P>If you come from a LAMP stack development background I am sure you have worked with sessions before. Typically a formal session is not used with a RESTful api as the api should be stateless to the user. That being said you cant really secure the api if the user has no state on the server. So how does one secure a server with little to no user state. One method would be to provide the user with their ID which they use as authentication. The implementation of this method is very simple but it comes with some serious exploitation issues. ID&#39;s are typically permanent assignments so If a malicious user gets ahold of someones ID they now have unlimited access to the account. This is problematic think of it as having a house that has a keypad door lock with a static code of your address. anyone that knows your address would have access to your home and learning the address can be done by any other person.</P>
		<P>This is why we often use a session. This would be like everyone that enters your house is granted access for a set amount of time before they have to leave and come back. Sessions allow servers the ability to invalidate a users access based on a set series of credentials. This method requires the server do a session lookup then a user lookup prior to completing any actions that the user has requested of the server. In a small environment this may not be problematic however does not scale well when dealing with a large user base. This method will result in each request taking longer to satisfy and a larger storage requirement. Often this will also require the implementation of some sort of CRON job to clear out expired sessions.</P>
		<P>A lighter weight alternative to this method is to assign a token to the user that can be used to lookup the user. Depending on the database you are using this token can be optimized as an index to reduce lookup time. For sql making the column an index column or on most nosql databases the field can be set to unique which creates a index method for the said key.</P>
		<P>This method has drawbacks as well. If you want each device using this account to have a separate token you are back to having a session table or document that has a one-one relationship to users.</P>
		<P>This drawback can become a positive side effect if you are trying to limit the number of devices a user is allowed to use to one. By invalidating the existing token with a new token when a new device signs in the previous device can be logged in within the same operation.</P>
		<P>This method can be optimized by using a token in which the date the token was created can be derived from the token. With the special token the date can be checked prior to any lookups and if the token is older then a specified time span the token can be ignored because its to old. If your in a pinch something like ULID can be used to generate a UUID that contains a timestamp.</P>
	</Section>
	<Section>
		<Title step={2} h={5} title="API Keys"/>
		<P>This method typically uses a token that is generated by a sister site and is hidden behind a different authentication scheme (i.e. you must be logged into acme.com to generate an api key for acmeproducts.com). This method however allows users to control their api keys in the event they believe an api key has been obtained by a malicious entity they can invalidate it and create a new one.</P>
		<P>An Api key can be a UUID or ULID or any other type if unique identifier as long as the key is unique to each user.</P>
		<P>Often this method will utilize a secret set by the user which is used as a key to encode or decode important information. In such scenarios its likely the Api key is a jwt token. Keep reading for more information on jwt tokens.</P>
	</Section>
	<Section>
		<Title step={3} h={5} title="JSON Web Tokens"/>
		<P>A JSON Web Token (jwt) is a token which is an encoded version of a JSON document so information can be parsed directly from the token without the need for a database lookup. That being said the amount of information in this token should be limited to the necessary information. Storing a full user record for instance will result in a very large token which is usually at least 33% bigger as a result of base64 encoding the JSON document.</P>
		<P>Similar to ULID&#39;s, jwt&#39;s usually contain a creation date allowing some validation to be performed prior to lookup up the user. However a jwt also typically contains the users id. This is usually a better solution then ULID because the user table no longer requires a unique field to lookup a session signature this also means the user record will not know anything about the existing sessions. However without additional systems in place this method will not be able to determine if the user is logged in on multiple devices.</P>
	</Section>
	<Section>
		<Title step={4} h={5} title="3rd party authentication"/>
		<P>In most cases this is not a viable option for securing an Api by itself as it will require the user to log into a 3rd party website and that websites token will be used as an authentication token on your api as well. That being said if you are designing a companion application to your api support for these logins can be provided and make your application even more accessible.</P>
	</Section>
	<Section>
		<Title step={5} h={5} title="Multi-factor authentication"/>
		<P>Multi-factor authentication can get very complex however in its simplest form the server sends an access key to a trusted contact method and restricts access until the user can provide that key. To avoid brute force attacks this key will typically only be valid for a very short period of time.</P>
		<P>Now that you understand how Multi-factor authentication works on its nose lets talk about how rolling codes and how they factor into this multi-factor authentication scheme. Most of these authenticators will not use your phone number or email as an authentication method but instead use a authentication service. These services continually generate whats called a rolling code. This rolling code can be derived from a secret and a generation time. This allows your api to contact the authentication service to confirm if the code provided is valid without ever having to generate or know the code prior to the authentication requrest.</P>
	</Section>
	<Section>
		<Title h={3} title="Closing Remarks"/>
		<P>As you can see authentication is a rabbit hole that is very easy to get lost in and unfortunately authentication practices are a moving target because as computers become more powerful hackers ability to circumvent or breach security measures becomes more powerful as well. Not to mention user authentication is only a small portion (but very important) of securing your api. With things like the 0 day attack or Npms path vulnerability exploit. hackers are able to gain access to the operating system your server is running. At which point they can monitor the memory cache and collect information passively until someone detects the hacker. As such it is important to utilize encrypted connections like https or wps to communicate with the client side. Also making sure that all dependencies are not only trust worthy but utilizing trust worthy dependencies as well. There are many tools to assist with this. One tool I see many developers ignore is the npm audit tool. That being said contiunual security improvements should be used to protect your api and your users. With that I will warn you not to roll your own security solutions. You might be smart even the smartest person in the world however cyber security is a multibillion dollar industry with a huge workforce working to improve these security practices daily. Using a tried and true security strategy is going to allow you to quickly develop a secure server.</P>
	</Section>
</Article>);

export const metadata: Metadata = {
	title: "Securing your Api and things to avoid",
	description: "Security seems easy until its to late.",
};
export default Page;